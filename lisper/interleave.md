# 交替两个列表

实现函数 `interleave`，该函数接受两个列表 `lst1` 和 `lst2` 作为参数，并返回一个新的列表，该列表从 `lst1` 开始，交替包含两个列表的元素。

如果输入的一个列表比另一个短，`interleave` 应该在较短的列表用完之前交替包含两个列表的元素，然后将较长列表的剩余元素追加到结果的末尾。如果 `lst1` 或 `lst2` 为空，函数应该直接返回另一个非空列表。

例如：

- `(interleave '(1 2 3) '(4 5 6))` 应该返回 `(1 4 2 5 3 6)`。
- `(interleave '(7 8 9 10) '(11 12))` 应该返回 `(7 11 8 12 9 10)`。

## 尾递归

```scheme
; 主函数：交错合并两个列表
; 参数：lst1 和 lst2 是要合并的两个输入列表
(define (interleave lst1 lst2)
    ; 辅助函数：使用累加器实现交错合并
    ; l1, l2: 待处理的剩余列表
    ; acc: 累加器,存储已合并的结果(倒序)
    (define (helper l1 l2 acc)
        (cond
           ; 两个列表都为空时,返回累加器的反转结果
           (
            (and (null? l1) (null? l2))
            (everse acc)  ; 需要反转因为我们是从头部添加的
            )
           ; l1为空,继续处理l2的剩余元素
           ( (null? l1) (helper l1 (cdr l2) (cons (car l2) acc)))
           ; l2为空,继续处理l1的剩余元素
           ( (null? l2) (helper (cdr l1) l2 (cons (car l1) acc)))
           ; 两个列表都非空,取出各自的头部元素交错添加到acc
           (else
            (helper (cdr l1) (cdr l2) (cons (car l2) (cons(car l1) acc)))
           )
        )
    )
    ; 调用辅助函数,初始累加器为空列表
    (helper lst1 lst2 '())
)
```

主要实现逻辑:

1. 使用辅助函数 helper 和累加器 acc 来实现
2. 递归处理两个输入列表,每次取出头部元素
3. 按照交错顺序将元素添加到累加器
4. 当有一个列表为空时,继续处理另一个列表的剩余元素
5. 最后反转累加器得到结果

## 非尾递归

```scheme
; 主函数：交错合并两个列表的递归实现
; 参数：lst1 和 lst2 是要合并的两个输入列表
(define (interleave lst1 lst2)
    (cond
        ; 如果第一个列表为空,返回第二个列表的所有剩余元素
        ((null? lst1) lst2)
        ; 如果第二个列表为空,返回第一个列表的所有剩余元素
        ((null? lst2) lst1)
        ; 两个列表都非空时：
        (else
            ; 1. 取出lst1的第一个元素作为结果的第一个元素
            ; 2. 取出lst2的第一个元素作为结果的第二个元素
            ; 3. 递归处理两个列表的剩余部分
            (cons (car lst1)
                  (cons (car lst2)
                        (interleave (cdr lst1) (cdr lst2)))) )))
```

- 代码更简洁易读
- 每次递归调用都需要保持当前的执行上下文
- 空间复杂度是 O(n)，其中 n 是较短列表的长度
