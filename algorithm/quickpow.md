# 快速幂

---

### **1. 偶数指数的处理**

当 $n$ 是偶数时，可以使用以下公式：

$$
x^n = (x^2)^{n/2}
$$

**步骤**：

1. 将指数 $n$ 减半（即 $n = \frac{n}{2}$）。
2. 将底数 $x$ 自己乘以自己（提前计算平方值，即 $x = x \cdot x$）。
3. 递归处理直到 $n = 0$。

---

### **2. 奇数指数的处理**

当 $n$ 是奇数时，无法直接使用偶数公式。这时可以先将 $n$ 拆分为：

$$
x^n = x \cdot x^{n-1}
$$

对于 $n-1$，它是偶数，因此可以用偶数公式处理：

$$
x^n = x \cdot (x^2)^{(n-1)/2}
$$

**步骤**：

1. 先将 $n$ 减 1，使其变成偶数（即 $n = n - 1$）。
2. 按照偶数公式递归处理 $x^{(n-1)/2}$。
3. 外面额外乘上一个 $x$。

---

### **3. 快速幂递归的核心逻辑**

在递归实现中：

- 如果 $n$ 是偶数：
  - 将 $x$ 替换为 $x \cdot x$（提前计算平方值）。
  - 将 $n$ 替换为 $n / 2$。
- 如果 $n$ 是奇数：
  - 先将 $n$ 减 1，使其变成偶数。
  - 按照偶数公式处理剩下的部分。
  - 最后额外乘一个 $x$。

---

### **4. 举例：计算 $2^9$**

我们以计算 $2^9$ 为例，观察快速幂的执行过程。

#### **初始值**：

$x = 2$, $n = 9$。

#### **第一步**：

- $n = 9$ 是奇数。
- 按公式拆解：
  $$
  2^9 = 2 \cdot 2^8
  $$
- 递归处理 $2^8$。

---

#### **第二步**：

- $n = 8$ 是偶数。
- 按公式拆解：
  $$
  2^8 = (2^4)^2
  $$
- 递归处理 $2^4$。

---

#### **第三步**：

- $n = 4$ 是偶数。
- 按公式拆解：
  $$
  2^4 = (2^2)^2
  $$
- 递归处理 $2^2$。

---

#### **第四步**：

- $n = 2$ 是偶数。
- 按公式拆解：
  $$
  2^2 = (2^1)^2
  $$
- 递归处理 $2^1$。

---

#### **第五步**：

- $n = 1$ 是奇数。
- 按公式拆解：
  $$
  2^1 = 2
  $$
- 递归终止。

---

#### **回溯计算**：

逐步计算结果：

1. $2^1 = 2$。
2. $2^2 = 2 \cdot 2 = 4$。
3. $2^4 = 4 \cdot 4 = 16$。
4. $2^8 = 16 \cdot 16 = 256$。
5. $2^9 = 2 \cdot 256 = 512$。

---

### **5. 快速幂的效率分析**

#### **时间复杂度**：

快速幂的核心在于：

- 每次递归将 $n$ 减半（奇数时通过 $n-1$ 转为偶数后继续减半）。
- 递归深度为 $\log_2(n)$。
- 每次递归只需常数时间的乘法操作。

因此，时间复杂度为：

$$
O(\log n)
$$

相比于普通幂运算（线性复杂度 $O(n)$），快速幂在指数较大时效率提升显著。

---

### **6. 总结**

1. **偶数处理**：

   - 直接用公式 $x^n = (x^2)^{n/2}$。
   - 将 $x$ 替换为 $x \cdot x$，$n$ 替换为 $n / 2$。

2. **奇数处理**：

   - 先将 $n$ 减 1，使其变为偶数。
   - 用公式 $x^n = x \cdot (x^{(n-1)/2})^2$。
   - 最后额外乘一个 $x$。

3. **效率来源**：
   - 每次递归指数减半，递归深度为 $\log_2(n)$。
   - 这种分治思想显著减少了计算量。

python 迭代版本

```python
def quickpow(x, n):
  if n==0:
    return 1
  if n < 0:
    n = -n
    x = 1/x
  while n:
    if n & 1:
      res *= x
    x *= x
    n >>= 1 # 右移一位，相当于整除以2
  return res
```

scheme 版本

```scheme
(define (quickpow x n)
  (cond ((= n 0) 1)
        ((< n 0) (quickpow (/ 1 x) (- n)))
        ((odd? n) (* x (quickpow (* x x) (quotient (- n 1) 2))))
        (else (quickpow (* x x) (quotient n 2)))))
```
