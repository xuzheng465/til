# 最小查询

## 问题描述

给定一个数组，要求查询数组中任意区间的最小值。

解决区间最小值查询问题。比如：

- 在数组 [3,1,4,2,5] 中
- 想快速查询任意区间的最小值
- 例如：查询区间[1,4]内的最小值（即 1,4,2,5 中的最小值是 1）

## 解法

### 线段树

TODO

### 稀疏表

```python
def preprocess(arr):
    n = len(arr)
    log_n = len(bin(n)) - 2
    dp = [[float('inf')] * log_n for _ in range(n)]

    # 初始化长度为1的区间
    for i in range(n):
        dp[i][0] = arr[i]

    # 填充其他长度的区间
    for j in range(1, log_n):
        for i in range(n - (1 << j) + 1):
            dp[i][j] = min(dp[i][j-1], dp[i + (1 << (j-1))][j-1])

    return dp

def query(dp, left, right):
    length = right - left + 1
    k = len(bin(length)) - 3
    return min(dp[left][k], dp[right - (1 << k) + 1][k])

if __name__ == "__main__":
    arr = [3, 1, 4, 2, 5]
    dp = preprocess(arr)

    # 打印dp表格
    print("DP表格：")
    for i in range(len(arr)):
        print(dp[i])

    # 测试不同区间查询
    print("\n查询结果：")
    print("区间[1,4]的最小值:", query(dp, 1, 4))  # 应该输出1
    print("区间[2,4]的最小值:", query(dp, 2, 4))  # 应该输出2
    print("区间[0,2]的最小值:", query(dp, 0, 2))  # 应该输出1
```

预处理数组，建立一张特殊的表格(dp 表)：

- 表格中存储了不同长度区间的最小值
- 长度必须是 2 的幂次方（1,2,4,8...）
- 这样任何查询都能用两个区间来覆盖

dp 表格的含义：

- `dp[i][j]` 表示：
  - 从位置 $i$ 开始
  - 长度为 $2^j$ 的区间的最小值

```shell
dp[2][0] = 4     表示从位置2开始，长度为1的区间[4]
dp[2][1] = 2     表示从位置2开始，长度为2的区间[4,2]的最小值
dp[0][1] = 1     表示从位置0开始，长度为2的区间[3,1]的最小值
```

#### dp 表格是如何构建的

第一步：填写长度为 1 的区间（$j=0$）

```
dp[i][0] 就是数组本身：
[3,1,4,2,5]
```

第二步：填写长度为 2 的区间（j=1）

```shell
dp[i][1] = min(dp[i][0], dp[i+1][0])

dp[0][1] = min(3,1) = 1    表示[3,1]
dp[1][1] = min(1,4) = 1    表示[1,4]
dp[2][1] = min(4,2) = 2    表示[4,2]
dp[3][1] = min(2,5) = 2    表示[2,5]
相邻两个数比较：
 ↓ ↓
[3,1],4,2,5     dp[0][1] = min(3,1) = 1
   ↓ ↓
3,[1,4],2,5     dp[1][1] = min(1,4) = 1
     ↓ ↓
3,1,[4,2],5     dp[2][1] = min(4,2) = 2
       ↓ ↓
3,1,4,[2,5]     dp[3][1] = min(2,5) = 2
```

第三步：填写长度为 4 的区间（j=2）

```shell
dp[i][2] = min(dp[i][1], dp[i+2][1])

dp[0][2] = min([3,1]的最小值, [4,2]的最小值) = 1    表示[3,1,4,2]
dp[1][2] = min([1,4]的最小值, [2,5]的最小值) = 1    表示[1,4,2,5]

比较前2个数的最小值和后2个数的最小值：
  前2个     后2个
   ↓         ↓
[{3,1}, {4,2}],5    dp[0][2] = min(dp[0][1], dp[2][1])
                                = min(1, 2) = 1
    前2个     后2个
     ↓         ↓
3,[{1,4}, {2,5}]    dp[1][2] = min(dp[1][1], dp[3][1])
                                = min(1, 2) = 1
```

对于数组 [3,1,4,2,5]（长度为 5）：

```shell
j=0: 长度为2⁰=1  [3] [1] [4] [2] [5]
j=1: 长度为2¹=2  [3,1] [1,4] [4,2] [2,5]
j=2: 长度为2²=4  [3,1,4,2] [1,4,2,5]
j=3: 长度为2³=8  ❌不可能，因为数组总长度才5
```

为什么 j 不能等于 3：

- j=3 时，需要长度为 8 的区间
- 但数组总长度只有 5
- 没有足够的元素构成长度为 8 的区间

### 分块

TODO

### 单调栈

TODO

### 暴力解法

```python
def query_bruteforce(arr, left, right):
    min_val = arr[left]  # 初始化为区间第一个数
    for i in range(left + 1, right + 1):
        if arr[i] < min_val:
            min_val = arr[i]
    return min_val
```

1. 暴力解法：

   - 预处理时间：O(1)，不需要预处理
   - 每次查询时间：O(n)，其中 n 是查询区间的长度
   - 空间复杂度：O(1)，只需要一个变量存储最小值

2. 之前的 Sparse Table 方法：
   - 预处理时间：O(n log n)
   - 每次查询时间：O(1)
   - 空间复杂度：O(n log n)

比较：

1. 如果查询次数很少，暴力方法更好：

   - 不需要预处理时间
   - 代码简单，容易实现
   - 空间复杂度低

2. 如果查询次数很多，Sparse Table 方法更好：
   - 假设查询 m 次
   - 暴力法总时间：O(m \* n)
   - Sparse Table 总时间：O(n log n + m)
   - 当 m > n 时，Sparse Table 方法明显更优

举例：

- 如果数组长度 n=1000，查询次数 m=10：

  - 暴力法：约 10,000 次操作 （1 万次）
  - Sparse Table：约 10,000 次预处理 + 10 次查询 = 约 10,010 次操作 （1 万零 10 次）
  - 两种方法差不多

- 如果数组长度 n=1000，查询次数 m=10000：
  - 暴力法：约 10,000,000 次操作 （1 千万次）
  - Sparse Table：约 10,000 次预处理 + 10000 次查询 = 约 20,000 次操作 （2 万次）
  - Sparse Table 方法明显更优
